#:schema https://jj-vcs.github.io/jj/latest/config-schema.json

[user]
name = "Rostislav Raykov"
# set email per repo

[ui]
default-command = ["log", "-T", "log_with_files"]

[[--scope]]
--when.commands = ["diff", "show"]
[--scope.ui]
# https://github.com/jj-vcs/jj/blob/v0.25.0/docs/config.md#processing-contents-to-be-paged
pager = "delta"
# NOTE: this is required when using `delta` as a pager
diff-formatter = ":git"

[aliases]
b = ["fuzzy_bookmark"]
ba = ["bookmark", "list", "-a"]
d = ["diff"]
s = ["status"]
l = ["log", "-r", "(trunk()..@):: | (trunk()..@)-"]
la = ["log", "-r", "..@"]
ll = ["log", "-T", "builtin_log_detailed"]

credit = ["file", "annotate"]

fetch = ["git", "fetch"]
push = ["git", "push"]

# Retrunk a series. Typically used as `jj retrunk -s ...`, and notably can be
# used with open:
# - jj retrunk -s 'all:roots(open())'
retrunk = ["rebase", "-d", "trunk()"]

# Retrunk the current stack of work.
reheat = ["rebase", "-d", "trunk()", "-s", "all:roots(trunk()..stack(@))"]

# list or jump to bookmarks
fuzzy_bookmark = ["util", "exec", "--", "sh", "-c", """
if [ "x$1" = "x" ]; then
  jj bookmark list
else
  jj bookmark list -a -T 'separate("@", name, remote) ++ "\n"' 2> /dev/null | sort | uniq | fzf -f "$1" | head -n1 | xargs jj new
fi
""", ""]

# Bring the closest bookmark up to the closest pushable change or to the specified revision
tug = ["util", "exec", "--", "sh", "-c", """
if [ "x$1" = "x" ]; then
  jj bookmark move --from "closest_bookmark(@)" --to "closest_pushable(@)"
else
  jj bookmark move --to "closest_pushable(@)" "$@"
fi
""", ""]

# colocate with git and track origin's branches
init = ["util", "exec", "--", "bash", "-c", """
jj git init --colocate
# only track origin branches, not upstream or others
jj bookmark track 'glob:*@origin'
"""]

# update from remote and rebase onto the latest
pull = ["util", "exec", "--", "bash", "-c", """
closest="$(jj log -r 'closest_bookmark(@)' -n 1 -T 'bookmarks' --no-graph | cut -d ' ' -f 1)"
closest="${closest%\\*}"
jj git fetch
jj log -n 1 -r "${closest}" 2>&1 > /dev/null && jj rebase -d "${closest}" || jj rebase -d 'trunk()'
jj log -r 'stack()'
"""]

# Get all open stacks of work.
open = ["log", "-r", "open()"]

# Show the current stack
stack = ["log", "-r", "stack()"]


[revset-aliases]
# Local commits not yet pushed
"local" = "all() ~ ancestors(remote_bookmarks())"

# Find closest bookmark to a commit
"closest_bookmark(to)" = "heads(::to & bookmarks())"

# trunk() by default resolves to the latest 'main'/'master' remote bookmark. May
# require customization for repos like nixpkgs.
'trunk()' = 'latest((present(main) | present(master)) & remote_bookmarks())'

# anything which is a work in progress according to the description
wip = 'description(regex:"^\\[(wip|WIP|todo|TODO)\\]|(wip|WIP|todo|TODO):?")'

# anything by a specific user, based on substring search of name or email
'user(x)' = 'author(x) | committer(x)'

# closest rev which is ok to be pushed (mutable, having description, not empty, not a merge)
'closest_pushable(to)' = 'heads(::to & mutable() & ~description(exact:"") & (~empty() | merges()))'

# stack(x, n) is the set of mutable commits reachable from 'x',
# with 'n' parents. 'n' is often useful to customize the display
# and return set for certain operations. 'x' can be used to target
# the set of 'roots' to traverse, e.g. @ is the current stack.
'stack()' = 'stack(@)'
'stack(x)' = 'stack(x, 2)'
'stack(x, n)' = 'ancestors(reachable(x, mutable()), n)'

# The current set of "open" works. It is defined as:
#
# - given the set of commits not in trunk, that are written by me,
# - calculate the given stack() for each of those commits
#
# n = 1, meaning that nothing from `trunk()` is included, so all resulting
# commits are mutable by definition.
'open()' = 'stack(trunk().. & mine(), 1)'

# the set of 'ready()' commits. defined as the set of open commits, but nothing
# that is blacklisted or any of their children.
'ready()' = 'open() ~ unready()::'

'recent_work' = 'ancestors(visible_heads(), 3) & mutable()'

[template-aliases]
log_with_files = '''
if(root,
  format_root_commit(self),
  label(if(current_working_copy, "working_copy"),
    concat(
      format_short_commit_header(self) ++ "\n",
      separate(" ",
        if(empty, label("empty", "(empty)")),
        if(description,
          description.first_line(),
          label(if(empty, "empty"), description_placeholder),
        ),
      ) ++ "\n",
      if(self.contained_in("recent_work"), diff.summary()),
    ),
  )
)
'''
